/* 
 *  Copyright 2022 VMware, Inc.
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/vmware-tanzu/service-instance-migrator-for-cloud-foundry/pkg/cf"
	"github.com/vmware-tanzu/service-instance-migrator-for-cloud-foundry/pkg/migrate/cc"
)

type FakeService struct {
	CreateStub        func(string, string, *cf.ServiceInstance, string) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *cf.ServiceInstance
		arg4 string
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	CreateAppStub        func(string, string, string) (string, error)
	createAppMutex       sync.RWMutex
	createAppArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	createAppReturns struct {
		result1 string
		result2 error
	}
	createAppReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CreateServiceBindingStub        func(*cf.ServiceBinding, string, string) error
	createServiceBindingMutex       sync.RWMutex
	createServiceBindingArgsForCall []struct {
		arg1 *cf.ServiceBinding
		arg2 string
		arg3 string
	}
	createServiceBindingReturns struct {
		result1 error
	}
	createServiceBindingReturnsOnCall map[int]struct {
		result1 error
	}
	CreateServiceKeyStub        func(cf.ServiceInstance, cf.ServiceKey) error
	createServiceKeyMutex       sync.RWMutex
	createServiceKeyArgsForCall []struct {
		arg1 cf.ServiceInstance
		arg2 cf.ServiceKey
	}
	createServiceKeyReturns struct {
		result1 error
	}
	createServiceKeyReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(string, string, *cf.ServiceInstance) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *cf.ServiceInstance
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadManifestStub        func(string, string, string) (cf.Application, error)
	downloadManifestMutex       sync.RWMutex
	downloadManifestArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	downloadManifestReturns struct {
		result1 cf.Application
		result2 error
	}
	downloadManifestReturnsOnCall map[int]struct {
		result1 cf.Application
		result2 error
	}
	FindAppByGUIDStub        func(string) (string, error)
	findAppByGUIDMutex       sync.RWMutex
	findAppByGUIDArgsForCall []struct {
		arg1 string
	}
	findAppByGUIDReturns struct {
		result1 string
		result2 error
	}
	findAppByGUIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ServiceInstanceExistsStub        func(string, string, string) (bool, error)
	serviceInstanceExistsMutex       sync.RWMutex
	serviceInstanceExistsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	serviceInstanceExistsReturns struct {
		result1 bool
		result2 error
	}
	serviceInstanceExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeService) Create(arg1 string, arg2 string, arg3 *cf.ServiceInstance, arg4 string) error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *cf.ServiceInstance
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3, arg4})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeService) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeService) CreateCalls(stub func(string, string, *cf.ServiceInstance, string) error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeService) CreateArgsForCall(i int) (string, string, *cf.ServiceInstance, string) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeService) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) CreateApp(arg1 string, arg2 string, arg3 string) (string, error) {
	fake.createAppMutex.Lock()
	ret, specificReturn := fake.createAppReturnsOnCall[len(fake.createAppArgsForCall)]
	fake.createAppArgsForCall = append(fake.createAppArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateAppStub
	fakeReturns := fake.createAppReturns
	fake.recordInvocation("CreateApp", []interface{}{arg1, arg2, arg3})
	fake.createAppMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) CreateAppCallCount() int {
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	return len(fake.createAppArgsForCall)
}

func (fake *FakeService) CreateAppCalls(stub func(string, string, string) (string, error)) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = stub
}

func (fake *FakeService) CreateAppArgsForCall(i int) (string, string, string) {
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	argsForCall := fake.createAppArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) CreateAppReturns(result1 string, result2 error) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = nil
	fake.createAppReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) CreateAppReturnsOnCall(i int, result1 string, result2 error) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = nil
	if fake.createAppReturnsOnCall == nil {
		fake.createAppReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createAppReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) CreateServiceBinding(arg1 *cf.ServiceBinding, arg2 string, arg3 string) error {
	fake.createServiceBindingMutex.Lock()
	ret, specificReturn := fake.createServiceBindingReturnsOnCall[len(fake.createServiceBindingArgsForCall)]
	fake.createServiceBindingArgsForCall = append(fake.createServiceBindingArgsForCall, struct {
		arg1 *cf.ServiceBinding
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateServiceBindingStub
	fakeReturns := fake.createServiceBindingReturns
	fake.recordInvocation("CreateServiceBinding", []interface{}{arg1, arg2, arg3})
	fake.createServiceBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeService) CreateServiceBindingCallCount() int {
	fake.createServiceBindingMutex.RLock()
	defer fake.createServiceBindingMutex.RUnlock()
	return len(fake.createServiceBindingArgsForCall)
}

func (fake *FakeService) CreateServiceBindingCalls(stub func(*cf.ServiceBinding, string, string) error) {
	fake.createServiceBindingMutex.Lock()
	defer fake.createServiceBindingMutex.Unlock()
	fake.CreateServiceBindingStub = stub
}

func (fake *FakeService) CreateServiceBindingArgsForCall(i int) (*cf.ServiceBinding, string, string) {
	fake.createServiceBindingMutex.RLock()
	defer fake.createServiceBindingMutex.RUnlock()
	argsForCall := fake.createServiceBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) CreateServiceBindingReturns(result1 error) {
	fake.createServiceBindingMutex.Lock()
	defer fake.createServiceBindingMutex.Unlock()
	fake.CreateServiceBindingStub = nil
	fake.createServiceBindingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) CreateServiceBindingReturnsOnCall(i int, result1 error) {
	fake.createServiceBindingMutex.Lock()
	defer fake.createServiceBindingMutex.Unlock()
	fake.CreateServiceBindingStub = nil
	if fake.createServiceBindingReturnsOnCall == nil {
		fake.createServiceBindingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createServiceBindingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) CreateServiceKey(arg1 cf.ServiceInstance, arg2 cf.ServiceKey) error {
	fake.createServiceKeyMutex.Lock()
	ret, specificReturn := fake.createServiceKeyReturnsOnCall[len(fake.createServiceKeyArgsForCall)]
	fake.createServiceKeyArgsForCall = append(fake.createServiceKeyArgsForCall, struct {
		arg1 cf.ServiceInstance
		arg2 cf.ServiceKey
	}{arg1, arg2})
	stub := fake.CreateServiceKeyStub
	fakeReturns := fake.createServiceKeyReturns
	fake.recordInvocation("CreateServiceKey", []interface{}{arg1, arg2})
	fake.createServiceKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeService) CreateServiceKeyCallCount() int {
	fake.createServiceKeyMutex.RLock()
	defer fake.createServiceKeyMutex.RUnlock()
	return len(fake.createServiceKeyArgsForCall)
}

func (fake *FakeService) CreateServiceKeyCalls(stub func(cf.ServiceInstance, cf.ServiceKey) error) {
	fake.createServiceKeyMutex.Lock()
	defer fake.createServiceKeyMutex.Unlock()
	fake.CreateServiceKeyStub = stub
}

func (fake *FakeService) CreateServiceKeyArgsForCall(i int) (cf.ServiceInstance, cf.ServiceKey) {
	fake.createServiceKeyMutex.RLock()
	defer fake.createServiceKeyMutex.RUnlock()
	argsForCall := fake.createServiceKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeService) CreateServiceKeyReturns(result1 error) {
	fake.createServiceKeyMutex.Lock()
	defer fake.createServiceKeyMutex.Unlock()
	fake.CreateServiceKeyStub = nil
	fake.createServiceKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) CreateServiceKeyReturnsOnCall(i int, result1 error) {
	fake.createServiceKeyMutex.Lock()
	defer fake.createServiceKeyMutex.Unlock()
	fake.CreateServiceKeyStub = nil
	if fake.createServiceKeyReturnsOnCall == nil {
		fake.createServiceKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createServiceKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) Delete(arg1 string, arg2 string, arg3 *cf.ServiceInstance) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *cf.ServiceInstance
	}{arg1, arg2, arg3})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeService) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeService) DeleteCalls(stub func(string, string, *cf.ServiceInstance) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeService) DeleteArgsForCall(i int) (string, string, *cf.ServiceInstance) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeService) DownloadManifest(arg1 string, arg2 string, arg3 string) (cf.Application, error) {
	fake.downloadManifestMutex.Lock()
	ret, specificReturn := fake.downloadManifestReturnsOnCall[len(fake.downloadManifestArgsForCall)]
	fake.downloadManifestArgsForCall = append(fake.downloadManifestArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DownloadManifestStub
	fakeReturns := fake.downloadManifestReturns
	fake.recordInvocation("DownloadManifest", []interface{}{arg1, arg2, arg3})
	fake.downloadManifestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) DownloadManifestCallCount() int {
	fake.downloadManifestMutex.RLock()
	defer fake.downloadManifestMutex.RUnlock()
	return len(fake.downloadManifestArgsForCall)
}

func (fake *FakeService) DownloadManifestCalls(stub func(string, string, string) (cf.Application, error)) {
	fake.downloadManifestMutex.Lock()
	defer fake.downloadManifestMutex.Unlock()
	fake.DownloadManifestStub = stub
}

func (fake *FakeService) DownloadManifestArgsForCall(i int) (string, string, string) {
	fake.downloadManifestMutex.RLock()
	defer fake.downloadManifestMutex.RUnlock()
	argsForCall := fake.downloadManifestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) DownloadManifestReturns(result1 cf.Application, result2 error) {
	fake.downloadManifestMutex.Lock()
	defer fake.downloadManifestMutex.Unlock()
	fake.DownloadManifestStub = nil
	fake.downloadManifestReturns = struct {
		result1 cf.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeService) DownloadManifestReturnsOnCall(i int, result1 cf.Application, result2 error) {
	fake.downloadManifestMutex.Lock()
	defer fake.downloadManifestMutex.Unlock()
	fake.DownloadManifestStub = nil
	if fake.downloadManifestReturnsOnCall == nil {
		fake.downloadManifestReturnsOnCall = make(map[int]struct {
			result1 cf.Application
			result2 error
		})
	}
	fake.downloadManifestReturnsOnCall[i] = struct {
		result1 cf.Application
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindAppByGUID(arg1 string) (string, error) {
	fake.findAppByGUIDMutex.Lock()
	ret, specificReturn := fake.findAppByGUIDReturnsOnCall[len(fake.findAppByGUIDArgsForCall)]
	fake.findAppByGUIDArgsForCall = append(fake.findAppByGUIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindAppByGUIDStub
	fakeReturns := fake.findAppByGUIDReturns
	fake.recordInvocation("FindAppByGUID", []interface{}{arg1})
	fake.findAppByGUIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) FindAppByGUIDCallCount() int {
	fake.findAppByGUIDMutex.RLock()
	defer fake.findAppByGUIDMutex.RUnlock()
	return len(fake.findAppByGUIDArgsForCall)
}

func (fake *FakeService) FindAppByGUIDCalls(stub func(string) (string, error)) {
	fake.findAppByGUIDMutex.Lock()
	defer fake.findAppByGUIDMutex.Unlock()
	fake.FindAppByGUIDStub = stub
}

func (fake *FakeService) FindAppByGUIDArgsForCall(i int) string {
	fake.findAppByGUIDMutex.RLock()
	defer fake.findAppByGUIDMutex.RUnlock()
	argsForCall := fake.findAppByGUIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeService) FindAppByGUIDReturns(result1 string, result2 error) {
	fake.findAppByGUIDMutex.Lock()
	defer fake.findAppByGUIDMutex.Unlock()
	fake.FindAppByGUIDStub = nil
	fake.findAppByGUIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) FindAppByGUIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.findAppByGUIDMutex.Lock()
	defer fake.findAppByGUIDMutex.Unlock()
	fake.FindAppByGUIDStub = nil
	if fake.findAppByGUIDReturnsOnCall == nil {
		fake.findAppByGUIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findAppByGUIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeService) ServiceInstanceExists(arg1 string, arg2 string, arg3 string) (bool, error) {
	fake.serviceInstanceExistsMutex.Lock()
	ret, specificReturn := fake.serviceInstanceExistsReturnsOnCall[len(fake.serviceInstanceExistsArgsForCall)]
	fake.serviceInstanceExistsArgsForCall = append(fake.serviceInstanceExistsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ServiceInstanceExistsStub
	fakeReturns := fake.serviceInstanceExistsReturns
	fake.recordInvocation("ServiceInstanceExists", []interface{}{arg1, arg2, arg3})
	fake.serviceInstanceExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) ServiceInstanceExistsCallCount() int {
	fake.serviceInstanceExistsMutex.RLock()
	defer fake.serviceInstanceExistsMutex.RUnlock()
	return len(fake.serviceInstanceExistsArgsForCall)
}

func (fake *FakeService) ServiceInstanceExistsCalls(stub func(string, string, string) (bool, error)) {
	fake.serviceInstanceExistsMutex.Lock()
	defer fake.serviceInstanceExistsMutex.Unlock()
	fake.ServiceInstanceExistsStub = stub
}

func (fake *FakeService) ServiceInstanceExistsArgsForCall(i int) (string, string, string) {
	fake.serviceInstanceExistsMutex.RLock()
	defer fake.serviceInstanceExistsMutex.RUnlock()
	argsForCall := fake.serviceInstanceExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeService) ServiceInstanceExistsReturns(result1 bool, result2 error) {
	fake.serviceInstanceExistsMutex.Lock()
	defer fake.serviceInstanceExistsMutex.Unlock()
	fake.ServiceInstanceExistsStub = nil
	fake.serviceInstanceExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeService) ServiceInstanceExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.serviceInstanceExistsMutex.Lock()
	defer fake.serviceInstanceExistsMutex.Unlock()
	fake.ServiceInstanceExistsStub = nil
	if fake.serviceInstanceExistsReturnsOnCall == nil {
		fake.serviceInstanceExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.serviceInstanceExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	fake.createServiceBindingMutex.RLock()
	defer fake.createServiceBindingMutex.RUnlock()
	fake.createServiceKeyMutex.RLock()
	defer fake.createServiceKeyMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.downloadManifestMutex.RLock()
	defer fake.downloadManifestMutex.RUnlock()
	fake.findAppByGUIDMutex.RLock()
	defer fake.findAppByGUIDMutex.RUnlock()
	fake.serviceInstanceExistsMutex.RLock()
	defer fake.serviceInstanceExistsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cc.Service = new(FakeService)
