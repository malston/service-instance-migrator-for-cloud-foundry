/* 
 *  Copyright 2022 VMware, Inc.
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/vmware-tanzu/service-instance-migrator-for-cloud-foundry/pkg/config"
)

type FakeLoader struct {
	BoshConfigStub        func(bool) *config.Bosh
	boshConfigMutex       sync.RWMutex
	boshConfigArgsForCall []struct {
		arg1 bool
	}
	boshConfigReturns struct {
		result1 *config.Bosh
	}
	boshConfigReturnsOnCall map[int]struct {
		result1 *config.Bosh
	}
	CCDBConfigStub        func(string, bool) interface{}
	cCDBConfigMutex       sync.RWMutex
	cCDBConfigArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	cCDBConfigReturns struct {
		result1 interface{}
	}
	cCDBConfigReturnsOnCall map[int]struct {
		result1 interface{}
	}
	CFConfigStub        func(bool) *config.CloudController
	cFConfigMutex       sync.RWMutex
	cFConfigArgsForCall []struct {
		arg1 bool
	}
	cFConfigReturns struct {
		result1 *config.CloudController
	}
	cFConfigReturnsOnCall map[int]struct {
		result1 *config.CloudController
	}
	SourceApiConfigStub        func() *config.CloudController
	sourceApiConfigMutex       sync.RWMutex
	sourceApiConfigArgsForCall []struct {
	}
	sourceApiConfigReturns struct {
		result1 *config.CloudController
	}
	sourceApiConfigReturnsOnCall map[int]struct {
		result1 *config.CloudController
	}
	SourceBoshConfigStub        func() *config.Bosh
	sourceBoshConfigMutex       sync.RWMutex
	sourceBoshConfigArgsForCall []struct {
	}
	sourceBoshConfigReturns struct {
		result1 *config.Bosh
	}
	sourceBoshConfigReturnsOnCall map[int]struct {
		result1 *config.Bosh
	}
	SourceCCDBConfigStub        func(string) interface{}
	sourceCCDBConfigMutex       sync.RWMutex
	sourceCCDBConfigArgsForCall []struct {
		arg1 string
	}
	sourceCCDBConfigReturns struct {
		result1 interface{}
	}
	sourceCCDBConfigReturnsOnCall map[int]struct {
		result1 interface{}
	}
	TargetApiConfigStub        func() *config.CloudController
	targetApiConfigMutex       sync.RWMutex
	targetApiConfigArgsForCall []struct {
	}
	targetApiConfigReturns struct {
		result1 *config.CloudController
	}
	targetApiConfigReturnsOnCall map[int]struct {
		result1 *config.CloudController
	}
	TargetBoshConfigStub        func() *config.Bosh
	targetBoshConfigMutex       sync.RWMutex
	targetBoshConfigArgsForCall []struct {
	}
	targetBoshConfigReturns struct {
		result1 *config.Bosh
	}
	targetBoshConfigReturnsOnCall map[int]struct {
		result1 *config.Bosh
	}
	TargetCCDBConfigStub        func(string) interface{}
	targetCCDBConfigMutex       sync.RWMutex
	targetCCDBConfigArgsForCall []struct {
		arg1 string
	}
	targetCCDBConfigReturns struct {
		result1 interface{}
	}
	targetCCDBConfigReturnsOnCall map[int]struct {
		result1 interface{}
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLoader) BoshConfig(arg1 bool) *config.Bosh {
	fake.boshConfigMutex.Lock()
	ret, specificReturn := fake.boshConfigReturnsOnCall[len(fake.boshConfigArgsForCall)]
	fake.boshConfigArgsForCall = append(fake.boshConfigArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.BoshConfigStub
	fakeReturns := fake.boshConfigReturns
	fake.recordInvocation("BoshConfig", []interface{}{arg1})
	fake.boshConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) BoshConfigCallCount() int {
	fake.boshConfigMutex.RLock()
	defer fake.boshConfigMutex.RUnlock()
	return len(fake.boshConfigArgsForCall)
}

func (fake *FakeLoader) BoshConfigCalls(stub func(bool) *config.Bosh) {
	fake.boshConfigMutex.Lock()
	defer fake.boshConfigMutex.Unlock()
	fake.BoshConfigStub = stub
}

func (fake *FakeLoader) BoshConfigArgsForCall(i int) bool {
	fake.boshConfigMutex.RLock()
	defer fake.boshConfigMutex.RUnlock()
	argsForCall := fake.boshConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLoader) BoshConfigReturns(result1 *config.Bosh) {
	fake.boshConfigMutex.Lock()
	defer fake.boshConfigMutex.Unlock()
	fake.BoshConfigStub = nil
	fake.boshConfigReturns = struct {
		result1 *config.Bosh
	}{result1}
}

func (fake *FakeLoader) BoshConfigReturnsOnCall(i int, result1 *config.Bosh) {
	fake.boshConfigMutex.Lock()
	defer fake.boshConfigMutex.Unlock()
	fake.BoshConfigStub = nil
	if fake.boshConfigReturnsOnCall == nil {
		fake.boshConfigReturnsOnCall = make(map[int]struct {
			result1 *config.Bosh
		})
	}
	fake.boshConfigReturnsOnCall[i] = struct {
		result1 *config.Bosh
	}{result1}
}

func (fake *FakeLoader) CCDBConfig(arg1 string, arg2 bool) interface{} {
	fake.cCDBConfigMutex.Lock()
	ret, specificReturn := fake.cCDBConfigReturnsOnCall[len(fake.cCDBConfigArgsForCall)]
	fake.cCDBConfigArgsForCall = append(fake.cCDBConfigArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.CCDBConfigStub
	fakeReturns := fake.cCDBConfigReturns
	fake.recordInvocation("CCDBConfig", []interface{}{arg1, arg2})
	fake.cCDBConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) CCDBConfigCallCount() int {
	fake.cCDBConfigMutex.RLock()
	defer fake.cCDBConfigMutex.RUnlock()
	return len(fake.cCDBConfigArgsForCall)
}

func (fake *FakeLoader) CCDBConfigCalls(stub func(string, bool) interface{}) {
	fake.cCDBConfigMutex.Lock()
	defer fake.cCDBConfigMutex.Unlock()
	fake.CCDBConfigStub = stub
}

func (fake *FakeLoader) CCDBConfigArgsForCall(i int) (string, bool) {
	fake.cCDBConfigMutex.RLock()
	defer fake.cCDBConfigMutex.RUnlock()
	argsForCall := fake.cCDBConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLoader) CCDBConfigReturns(result1 interface{}) {
	fake.cCDBConfigMutex.Lock()
	defer fake.cCDBConfigMutex.Unlock()
	fake.CCDBConfigStub = nil
	fake.cCDBConfigReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeLoader) CCDBConfigReturnsOnCall(i int, result1 interface{}) {
	fake.cCDBConfigMutex.Lock()
	defer fake.cCDBConfigMutex.Unlock()
	fake.CCDBConfigStub = nil
	if fake.cCDBConfigReturnsOnCall == nil {
		fake.cCDBConfigReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.cCDBConfigReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeLoader) CFConfig(arg1 bool) *config.CloudController {
	fake.cFConfigMutex.Lock()
	ret, specificReturn := fake.cFConfigReturnsOnCall[len(fake.cFConfigArgsForCall)]
	fake.cFConfigArgsForCall = append(fake.cFConfigArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.CFConfigStub
	fakeReturns := fake.cFConfigReturns
	fake.recordInvocation("CFConfig", []interface{}{arg1})
	fake.cFConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) CFConfigCallCount() int {
	fake.cFConfigMutex.RLock()
	defer fake.cFConfigMutex.RUnlock()
	return len(fake.cFConfigArgsForCall)
}

func (fake *FakeLoader) CFConfigCalls(stub func(bool) *config.CloudController) {
	fake.cFConfigMutex.Lock()
	defer fake.cFConfigMutex.Unlock()
	fake.CFConfigStub = stub
}

func (fake *FakeLoader) CFConfigArgsForCall(i int) bool {
	fake.cFConfigMutex.RLock()
	defer fake.cFConfigMutex.RUnlock()
	argsForCall := fake.cFConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLoader) CFConfigReturns(result1 *config.CloudController) {
	fake.cFConfigMutex.Lock()
	defer fake.cFConfigMutex.Unlock()
	fake.CFConfigStub = nil
	fake.cFConfigReturns = struct {
		result1 *config.CloudController
	}{result1}
}

func (fake *FakeLoader) CFConfigReturnsOnCall(i int, result1 *config.CloudController) {
	fake.cFConfigMutex.Lock()
	defer fake.cFConfigMutex.Unlock()
	fake.CFConfigStub = nil
	if fake.cFConfigReturnsOnCall == nil {
		fake.cFConfigReturnsOnCall = make(map[int]struct {
			result1 *config.CloudController
		})
	}
	fake.cFConfigReturnsOnCall[i] = struct {
		result1 *config.CloudController
	}{result1}
}

func (fake *FakeLoader) SourceApiConfig() *config.CloudController {
	fake.sourceApiConfigMutex.Lock()
	ret, specificReturn := fake.sourceApiConfigReturnsOnCall[len(fake.sourceApiConfigArgsForCall)]
	fake.sourceApiConfigArgsForCall = append(fake.sourceApiConfigArgsForCall, struct {
	}{})
	stub := fake.SourceApiConfigStub
	fakeReturns := fake.sourceApiConfigReturns
	fake.recordInvocation("SourceApiConfig", []interface{}{})
	fake.sourceApiConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) SourceApiConfigCallCount() int {
	fake.sourceApiConfigMutex.RLock()
	defer fake.sourceApiConfigMutex.RUnlock()
	return len(fake.sourceApiConfigArgsForCall)
}

func (fake *FakeLoader) SourceApiConfigCalls(stub func() *config.CloudController) {
	fake.sourceApiConfigMutex.Lock()
	defer fake.sourceApiConfigMutex.Unlock()
	fake.SourceApiConfigStub = stub
}

func (fake *FakeLoader) SourceApiConfigReturns(result1 *config.CloudController) {
	fake.sourceApiConfigMutex.Lock()
	defer fake.sourceApiConfigMutex.Unlock()
	fake.SourceApiConfigStub = nil
	fake.sourceApiConfigReturns = struct {
		result1 *config.CloudController
	}{result1}
}

func (fake *FakeLoader) SourceApiConfigReturnsOnCall(i int, result1 *config.CloudController) {
	fake.sourceApiConfigMutex.Lock()
	defer fake.sourceApiConfigMutex.Unlock()
	fake.SourceApiConfigStub = nil
	if fake.sourceApiConfigReturnsOnCall == nil {
		fake.sourceApiConfigReturnsOnCall = make(map[int]struct {
			result1 *config.CloudController
		})
	}
	fake.sourceApiConfigReturnsOnCall[i] = struct {
		result1 *config.CloudController
	}{result1}
}

func (fake *FakeLoader) SourceBoshConfig() *config.Bosh {
	fake.sourceBoshConfigMutex.Lock()
	ret, specificReturn := fake.sourceBoshConfigReturnsOnCall[len(fake.sourceBoshConfigArgsForCall)]
	fake.sourceBoshConfigArgsForCall = append(fake.sourceBoshConfigArgsForCall, struct {
	}{})
	stub := fake.SourceBoshConfigStub
	fakeReturns := fake.sourceBoshConfigReturns
	fake.recordInvocation("SourceBoshConfig", []interface{}{})
	fake.sourceBoshConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) SourceBoshConfigCallCount() int {
	fake.sourceBoshConfigMutex.RLock()
	defer fake.sourceBoshConfigMutex.RUnlock()
	return len(fake.sourceBoshConfigArgsForCall)
}

func (fake *FakeLoader) SourceBoshConfigCalls(stub func() *config.Bosh) {
	fake.sourceBoshConfigMutex.Lock()
	defer fake.sourceBoshConfigMutex.Unlock()
	fake.SourceBoshConfigStub = stub
}

func (fake *FakeLoader) SourceBoshConfigReturns(result1 *config.Bosh) {
	fake.sourceBoshConfigMutex.Lock()
	defer fake.sourceBoshConfigMutex.Unlock()
	fake.SourceBoshConfigStub = nil
	fake.sourceBoshConfigReturns = struct {
		result1 *config.Bosh
	}{result1}
}

func (fake *FakeLoader) SourceBoshConfigReturnsOnCall(i int, result1 *config.Bosh) {
	fake.sourceBoshConfigMutex.Lock()
	defer fake.sourceBoshConfigMutex.Unlock()
	fake.SourceBoshConfigStub = nil
	if fake.sourceBoshConfigReturnsOnCall == nil {
		fake.sourceBoshConfigReturnsOnCall = make(map[int]struct {
			result1 *config.Bosh
		})
	}
	fake.sourceBoshConfigReturnsOnCall[i] = struct {
		result1 *config.Bosh
	}{result1}
}

func (fake *FakeLoader) SourceCCDBConfig(arg1 string) interface{} {
	fake.sourceCCDBConfigMutex.Lock()
	ret, specificReturn := fake.sourceCCDBConfigReturnsOnCall[len(fake.sourceCCDBConfigArgsForCall)]
	fake.sourceCCDBConfigArgsForCall = append(fake.sourceCCDBConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SourceCCDBConfigStub
	fakeReturns := fake.sourceCCDBConfigReturns
	fake.recordInvocation("SourceCCDBConfig", []interface{}{arg1})
	fake.sourceCCDBConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) SourceCCDBConfigCallCount() int {
	fake.sourceCCDBConfigMutex.RLock()
	defer fake.sourceCCDBConfigMutex.RUnlock()
	return len(fake.sourceCCDBConfigArgsForCall)
}

func (fake *FakeLoader) SourceCCDBConfigCalls(stub func(string) interface{}) {
	fake.sourceCCDBConfigMutex.Lock()
	defer fake.sourceCCDBConfigMutex.Unlock()
	fake.SourceCCDBConfigStub = stub
}

func (fake *FakeLoader) SourceCCDBConfigArgsForCall(i int) string {
	fake.sourceCCDBConfigMutex.RLock()
	defer fake.sourceCCDBConfigMutex.RUnlock()
	argsForCall := fake.sourceCCDBConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLoader) SourceCCDBConfigReturns(result1 interface{}) {
	fake.sourceCCDBConfigMutex.Lock()
	defer fake.sourceCCDBConfigMutex.Unlock()
	fake.SourceCCDBConfigStub = nil
	fake.sourceCCDBConfigReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeLoader) SourceCCDBConfigReturnsOnCall(i int, result1 interface{}) {
	fake.sourceCCDBConfigMutex.Lock()
	defer fake.sourceCCDBConfigMutex.Unlock()
	fake.SourceCCDBConfigStub = nil
	if fake.sourceCCDBConfigReturnsOnCall == nil {
		fake.sourceCCDBConfigReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.sourceCCDBConfigReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeLoader) TargetApiConfig() *config.CloudController {
	fake.targetApiConfigMutex.Lock()
	ret, specificReturn := fake.targetApiConfigReturnsOnCall[len(fake.targetApiConfigArgsForCall)]
	fake.targetApiConfigArgsForCall = append(fake.targetApiConfigArgsForCall, struct {
	}{})
	stub := fake.TargetApiConfigStub
	fakeReturns := fake.targetApiConfigReturns
	fake.recordInvocation("TargetApiConfig", []interface{}{})
	fake.targetApiConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) TargetApiConfigCallCount() int {
	fake.targetApiConfigMutex.RLock()
	defer fake.targetApiConfigMutex.RUnlock()
	return len(fake.targetApiConfigArgsForCall)
}

func (fake *FakeLoader) TargetApiConfigCalls(stub func() *config.CloudController) {
	fake.targetApiConfigMutex.Lock()
	defer fake.targetApiConfigMutex.Unlock()
	fake.TargetApiConfigStub = stub
}

func (fake *FakeLoader) TargetApiConfigReturns(result1 *config.CloudController) {
	fake.targetApiConfigMutex.Lock()
	defer fake.targetApiConfigMutex.Unlock()
	fake.TargetApiConfigStub = nil
	fake.targetApiConfigReturns = struct {
		result1 *config.CloudController
	}{result1}
}

func (fake *FakeLoader) TargetApiConfigReturnsOnCall(i int, result1 *config.CloudController) {
	fake.targetApiConfigMutex.Lock()
	defer fake.targetApiConfigMutex.Unlock()
	fake.TargetApiConfigStub = nil
	if fake.targetApiConfigReturnsOnCall == nil {
		fake.targetApiConfigReturnsOnCall = make(map[int]struct {
			result1 *config.CloudController
		})
	}
	fake.targetApiConfigReturnsOnCall[i] = struct {
		result1 *config.CloudController
	}{result1}
}

func (fake *FakeLoader) TargetBoshConfig() *config.Bosh {
	fake.targetBoshConfigMutex.Lock()
	ret, specificReturn := fake.targetBoshConfigReturnsOnCall[len(fake.targetBoshConfigArgsForCall)]
	fake.targetBoshConfigArgsForCall = append(fake.targetBoshConfigArgsForCall, struct {
	}{})
	stub := fake.TargetBoshConfigStub
	fakeReturns := fake.targetBoshConfigReturns
	fake.recordInvocation("TargetBoshConfig", []interface{}{})
	fake.targetBoshConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) TargetBoshConfigCallCount() int {
	fake.targetBoshConfigMutex.RLock()
	defer fake.targetBoshConfigMutex.RUnlock()
	return len(fake.targetBoshConfigArgsForCall)
}

func (fake *FakeLoader) TargetBoshConfigCalls(stub func() *config.Bosh) {
	fake.targetBoshConfigMutex.Lock()
	defer fake.targetBoshConfigMutex.Unlock()
	fake.TargetBoshConfigStub = stub
}

func (fake *FakeLoader) TargetBoshConfigReturns(result1 *config.Bosh) {
	fake.targetBoshConfigMutex.Lock()
	defer fake.targetBoshConfigMutex.Unlock()
	fake.TargetBoshConfigStub = nil
	fake.targetBoshConfigReturns = struct {
		result1 *config.Bosh
	}{result1}
}

func (fake *FakeLoader) TargetBoshConfigReturnsOnCall(i int, result1 *config.Bosh) {
	fake.targetBoshConfigMutex.Lock()
	defer fake.targetBoshConfigMutex.Unlock()
	fake.TargetBoshConfigStub = nil
	if fake.targetBoshConfigReturnsOnCall == nil {
		fake.targetBoshConfigReturnsOnCall = make(map[int]struct {
			result1 *config.Bosh
		})
	}
	fake.targetBoshConfigReturnsOnCall[i] = struct {
		result1 *config.Bosh
	}{result1}
}

func (fake *FakeLoader) TargetCCDBConfig(arg1 string) interface{} {
	fake.targetCCDBConfigMutex.Lock()
	ret, specificReturn := fake.targetCCDBConfigReturnsOnCall[len(fake.targetCCDBConfigArgsForCall)]
	fake.targetCCDBConfigArgsForCall = append(fake.targetCCDBConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TargetCCDBConfigStub
	fakeReturns := fake.targetCCDBConfigReturns
	fake.recordInvocation("TargetCCDBConfig", []interface{}{arg1})
	fake.targetCCDBConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) TargetCCDBConfigCallCount() int {
	fake.targetCCDBConfigMutex.RLock()
	defer fake.targetCCDBConfigMutex.RUnlock()
	return len(fake.targetCCDBConfigArgsForCall)
}

func (fake *FakeLoader) TargetCCDBConfigCalls(stub func(string) interface{}) {
	fake.targetCCDBConfigMutex.Lock()
	defer fake.targetCCDBConfigMutex.Unlock()
	fake.TargetCCDBConfigStub = stub
}

func (fake *FakeLoader) TargetCCDBConfigArgsForCall(i int) string {
	fake.targetCCDBConfigMutex.RLock()
	defer fake.targetCCDBConfigMutex.RUnlock()
	argsForCall := fake.targetCCDBConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLoader) TargetCCDBConfigReturns(result1 interface{}) {
	fake.targetCCDBConfigMutex.Lock()
	defer fake.targetCCDBConfigMutex.Unlock()
	fake.TargetCCDBConfigStub = nil
	fake.targetCCDBConfigReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeLoader) TargetCCDBConfigReturnsOnCall(i int, result1 interface{}) {
	fake.targetCCDBConfigMutex.Lock()
	defer fake.targetCCDBConfigMutex.Unlock()
	fake.TargetCCDBConfigStub = nil
	if fake.targetCCDBConfigReturnsOnCall == nil {
		fake.targetCCDBConfigReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.targetCCDBConfigReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeLoader) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.boshConfigMutex.RLock()
	defer fake.boshConfigMutex.RUnlock()
	fake.cCDBConfigMutex.RLock()
	defer fake.cCDBConfigMutex.RUnlock()
	fake.cFConfigMutex.RLock()
	defer fake.cFConfigMutex.RUnlock()
	fake.sourceApiConfigMutex.RLock()
	defer fake.sourceApiConfigMutex.RUnlock()
	fake.sourceBoshConfigMutex.RLock()
	defer fake.sourceBoshConfigMutex.RUnlock()
	fake.sourceCCDBConfigMutex.RLock()
	defer fake.sourceCCDBConfigMutex.RUnlock()
	fake.targetApiConfigMutex.RLock()
	defer fake.targetApiConfigMutex.RUnlock()
	fake.targetBoshConfigMutex.RLock()
	defer fake.targetBoshConfigMutex.RUnlock()
	fake.targetCCDBConfigMutex.RLock()
	defer fake.targetCCDBConfigMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLoader) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ config.Loader = new(FakeLoader)
